{"name":"Clang","tagline":"Mirror of official clang git repository located at http://llvm.org/git/clang.  Updated every five minutes.","body":"Clang-Swifter\r\n=============\r\n\r\nHack-add a simple thirdparty Objective-C runtime to Clang. Documents just the\r\nprocess, not the actual implementation.\r\n\r\nLet's see whether I have the persistence to complete this 'tutorial' ;-)\r\nFeedback is welcome.\r\n\r\n### Intro\r\n\r\nAssume you came up with your own, personal, Objective-C runtime. All you miss is\r\na decent compiler ...\r\nNow Clang claims to be a very modular and easy to hack C compiler (specifically\r\ncompared to GCC). Let's see how it goes ... ;->\r\n\r\nRecommendation: If you want to understand Swift, it is a really good idea to\r\nread through the LLVM tutorials. It gives you an insight on where they are\r\ncoming from. Pretty much the same reason why it's a good idea to have a basic\r\nunderstanding of assembler when you are working in C, or of the JVM when you do\r\nJava.\r\n\r\n\r\n### Setup Xcode dev environment\r\n\r\nWe want to code the Clang stuff in Xcode, mostly for the debugger. This\r\nis easy to setup because the LLVM/Clang built system is based on \r\n[Cmake](http://www.cmake.org).\r\nCmake is a makefile generator, which can generate Makefiles, VisualStudio\r\nprojects, and Xcode ones. Not in a particulary good way, but OK.\r\n\r\nOSX doesn't come with cmake included, so I'd recommend to install it via\r\n[Homebrew](http://brew.sh):\r\n\r\n    brew install cmake\r\n\r\nNext checkout LLVM and Clang, in _separate_ directories. Not in one as suggested\r\nby the Clang [online documentation](http://clang.llvm.org/get_started.html).\r\nBoth repositories are BIG (LLVM 326MB, Clang 177MB!).\r\nI also suggest checking out a specific release branch (I chose release_36), as\r\nClang trunk is a moving target (even the release branches receive updates).\r\n\r\n    cd ~\r\n    mkdir hack-a-clang\r\n    cd hack-a-clang\r\n    \r\n    git clone -b release_36 http://llvm.org/git/llvm.git\r\n    git clone -b release_36 http://llvm.org/git/clang.git\r\n    \r\n    cd llvm/projects\r\n    git clone -b release_36 http://llvm.org/git/compiler-rt.git\r\n    cd ../..\r\n\r\nNext we create an LLVM build directory, let cmake create Makefiles and build\r\nClang.\r\n\r\n    cd ~/hack-a-clang\r\n    mkdir llvm-build\r\n    cd llvm-build\r\n    \r\n    cmake -G \"Unix Makefiles\" -DLLVM_ENABLE_CXX1Y:BOOL=OFF ../llvm\r\n      # throws warning, which we choose to ignore\r\n    \r\n    time make -s -j 8\r\n      # grab ☕️, then another ☕️ and one more ☕️\r\n\r\nAnd go ahead to Clang. You can build Clang using makefiles like above, but\r\nwe want to hack in Xcode. *Important*: Don't forget to setup the path to point\r\nto the LLVM bin directory.\r\nLooks like this:\r\n\r\n    cd ~/hack-a-clang\r\n    export PATH=\"`pwd`/llvm-build/bin:${PATH}\"\r\n    mkdir clang-build\r\n    cd clang-build\r\n    \r\n    cmake -G \"Xcode\" ../clang\r\n      # throws warning, which we choose to ignore\r\n    \r\n    time xcodebuild -target clang\r\n      # grab ☕️, then another ☕️ and one more ☕️\r\n\r\nIn case this worked right, you can now test Clang. This includes a set of\r\nuseful calls to the clang binary:\r\n\r\n    cd ~/hack-a-clang\r\n    export PATH=\"`pwd`/clang-build/Debug/bin:${PATH}\"\r\n    echo 'main() { printf(\"Hello World!\\n\"); return 0; }' > hello.m\r\n    \r\n    which clang # check it's picking up your clang\r\n      # e.g. /Users/helge/hack-a-clang/clang-build/Debug/bin/clang\r\n    \r\n    clang --help\r\n    clang hello.m -fsyntax-only\r\n    clang hello.m -S -emit-llvm -o - # print LLVM assembly code for hello.c\r\n    clang hello.m -S -emit-llvm -O3 -o -\r\n    clang hello.m -S -O3 -o -        # Intel assembly code (compiled by LLVM)\r\n    clang -Xclang -ast-dump -fsyntax-only hello.m\r\n\r\nIf all is good, you can fire up clang in Xcode:\r\n\r\n    cd ~/hack-a-clang\r\n    cd clang-build\r\n    open Clang.xcodeproj\r\n      # while Xcode indexes the source, grab ☕️, then another ☕️\r\n\r\nThe project is HUGE. First, switch the target from 'ALL_BUILD' to 'clang'\r\n(somewhere at the bottom of the list).\r\n\r\n**Important**: Everytime cmake detects something it considers a change, it'll\r\nregenerate your Xcode project. So while you can setup new groups and such in\r\nXcode, this is a lossy process. Don't invest too much time into that.\r\n\r\nNext, lets setup Xcode for debugging. Go to the target popup and select\r\n'Edit Scheme'. In the 'Run' section add those arguments:\r\n\r\n    -cc1\r\n    $(HOME)/hack-a-clang/hello.m\r\n    -S\r\n    -emit-llvm\r\n    -o -\r\n\r\nPress Cmd-r to run it, and it should output the LLVM code for hello.m.\r\n\r\nGreat, we have a working development environment.\r\n\r\n\r\n### Intro 2\r\n\r\nSo what is Clang. Clang is a set of things. It's a preprocessor system,\r\nit is a C/C++/ObjC/ObjC++ parser and code generator. And it is a 'compiler\r\ndriver', aka the shell tool which wraps the compilation stages. The latter\r\nmakes the whole thing a bit weird, because both, the compiler and the driver\r\nare named 'clang'.\r\n\r\nSo the steps performed by the driver (when you call 'clang hello.m -o hello')\r\nare essentially:\r\n- take a file to compile\r\n- scan & preprocess it (convert source text into tokens)\r\n- parse it into an AST (a tree representation of the source),\r\n  this is actually two separate modules in clang:\r\n  - the parser (detect token sequences, feed the Sema)\r\n  - the Sema (semantic analyzer), which constructs the AST\r\n- CodeGen: emit LLVM IR code from the AST\r\n- let LLVM compile the IR\r\n- link the native code\r\n\r\nTo generate Objective-C code, the code generation needs to be adjusted. It\r\ntakes the AST and emits the LLVM IR (intermediate representation) code for this.\r\nIn the case of Objective-C this is stuff like message sends `[obj doIt]`,\r\nruntime meta data, or class/selector lookups (e.g. `@selector(doIt:)`).\r\n\r\n\r\nRemember that I said that 'clang' is both the driver executable and the\r\ncompiler? That turns out to be very confusing when you use the web to search\r\nfor options the tools take ... If you run 'clang' from the 'bin' build\r\ndirectory, you run the driver.\r\nIf you want to pass options to the compiler, there are two ways to do it.\r\nEither prepend every option with -Xclang:\r\n\r\n    clang -Xclang -ast-dump -fsyntax-only hello.m\r\n\r\nor invoke the compiler directly via -cc1, eg:\r\n\r\n    clang -cc1 -ast-dump hello.m\r\n\r\n\r\n### Reading Materials\r\n\r\nUpfront: When working on stuff like this I always take notes in\r\n[VoodooPad](https://plausible.coop/voodoopad/).\r\nI paste in links, I paste in sample source code, I take notes in it. All\r\nautomagically cross linked.\r\n\r\nOK, below a set of links which you might want to read.\r\n\r\n#### LLVM\r\n\r\nYou should definitely read through the\r\n[Kaleidoscope tutorial](http://llvm.org/docs/tutorial/).\r\nIt gives you a solid understanding of how to write a simple compiler which\r\ntargets LLVM.\r\n\r\nJIT tutorial: [A first function](http://llvm.org/releases/2.6/docs/tutorial/JITTutorial1.html) and\r\n[A more complicated function](http://llvm.org/releases/2.6/docs/tutorial/JITTutorial2.html).\r\nPretty good.\r\n\r\nAnother great one is\r\n[Mapping High-Level Constructs to LLVM IR](http://llvm.lyngvig.org/Articles/Mapping-High-Level-Constructs-to-LLVM-IR),\r\nwhich shows how C/C++ constructs look in LLVM assembly (IR) code.\r\nNote that this one is different from Kaleidoscope in that it doesn't show\r\nhow you create the IR at runtime. It shows the textual representation.\r\n\r\nLLVM IR is build around something called SSA - short for\r\n[Static single assignment form](http://en.wikipedia.org/wiki/Static_single_assignment_form),\r\nyou'll see references to this all over the place.\r\nDon't be too afraid when reading the article, you don't have to understand too\r\nmuch of it. Just remember that there is something called a 'Phi' function.\r\n\r\nAdvanced, look at this later:\r\n- getelementptr instruction (GEP)\r\n  - http://llvm.org/docs/GetElementPtr.html\r\n  - http://llvm.org/docs/LangRef.html#getelementptr-instruction\r\n\r\n#### Clang\r\n\r\nClang hacking docu: [Hacking on Clang](http://clang.llvm.org/hacking.html)\r\n\r\n[Kevin Boos Tutorial](https://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/),\r\nin three parts. Very nice.\r\nNote: this talks about Clang plugins and tooling. Which is absolutely worth\r\nreading (do it!), but neither technology is suitable for implementing a new\r\nruntime backend. For that you actually have to hack clang.\r\n\r\n[Introduction to the Clang AST](http://clang.llvm.org/docs/IntroductionToTheClangAST.html),\r\nOK to scan it, I didn't watch the video.\r\n\r\nOthers:\r\n- [What makes Clang so special](http://www.codergears.com/Blog/?p=679)\r\n- [Creating and using Clang plugin with Xcode](http://railsware.com/blog/2014/02/28/creation-and-using-clang-plugin-with-xcode/)\r\n- [Create a working compiler with the LLVM framework](http://www.ibm.com/developerworks/library/os-createcompilerllvm1/), [Part2](http://www.ibm.com/developerworks/library/os-createcompilerllvm2/)\r\n\r\n\r\n### Hack in a new runtime\r\n\r\nLet's start hacking in support for a new runtime. As mentioned the primary\r\nthing which needs to be adjusted is the code generator which transforms\r\nthe AST into LLVM IR.\r\n\r\nOpen the Xcode project and browse to:\r\n\r\n    Sources / Clang libraries / clangCodeGen / Source Files\r\n\r\nThis is the code generator.\r\n\r\n#### Step 1: Create a new generator class for the runtime\r\n\r\nNow Clang already comes with support for a set of different runtimes. Those\r\nare grouped into two families: Mac and GNU, both have a set of variants\r\n(eg fragile vs non-fragile etc.)\r\n\r\nThe runtime specific code generation parts are separated out in subclasses of\r\nthe 'CGObjCRuntime' class, e.g. there is CGObjCGCC (the runtime coming with the\r\nGCC compiler), CGObjCGNUstep (the modern GNUstep runtime), CGObjCObjFW (the\r\nruntime of the ObjFW kit).\r\n\r\nSo, it is kinda obvious what we need to do first: Create a new runtime CodeGen\r\nclass.\r\n\r\nOurs will be of neither family, it'll sideline both. Check the GIT commit to\r\nsee what needs to be done. To avoid having to implement every single code\r\ngenerator from the beginning, there is a base class which just contains the \r\n'virtuals' of CGObjCRuntime, with an abort() ([CGObjCSwifterVirtual.h](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CGObjCSwifterVirtual.h)).\r\nOur class itself lives in [CGObjCSwifter.h](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CGObjCSwifter.h)/[CGObjCSwifter.cpp](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CGObjCSwifter.cpp).\r\nRight now it's rather empty.\r\n\r\nTo add the new class to the compilation process, add CGObjCSwifter.cpp to\r\n[CMakeLists.txt](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CMakeLists.txt).\r\n*Again*: Any change here is going to recreate your xcodeproj, all your own\r\nfile groups and such will be gone.\r\n\r\n\r\n#### Step 2: Hook up the new runtime class to the driver\r\n\r\nOK, now we have our abort'y implementation of a new ObjC runtime backend. When\r\ncompiling a file, we need to tell Clang that we want to use it.\r\nTo select the runtime, Clang uses the `-fobjc-runtime=xyz` option, e.g.\r\n`-fobjc-runtime=gnustep` or `-fobjc-runtime=ios`.\r\nWhat we want is `-fobjc-runtime=swifter`.\r\n\r\nIn Clang this spreads out over various files with plenty of redundancy. But the\r\ncore is the ObjCRuntime.Kind enum in \r\n[ObjCRuntime.h](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/include/clang/Basic/ObjCRuntime.h)\r\nclass of the Basic library (so much for the famous Clang 'modularity' ...).\r\n*Important*: This class just represents the capabilities of a specific runtime\r\nversion, do *not* mix it up with the `CGObjCRuntime` class, which is the\r\nbase class for the ObjC code generator.\r\nThis object is accessed in various places within Clang, usually in a codepath like:\r\n    \r\n    if (LangOpts.ObjC1) {\r\n      if (LangOpts.ObjCRuntime.isNonFragile()) {\r\n        Builder.defineMacro(\"__OBJC2__\");\r\n\r\nSee the git commit for the details, but those are files we patch just to add\r\nSwifter to the enum:\r\n[ObjCRuntime.h](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/include/clang/Basic/ObjCRuntime.h),\r\n[ObjCRuntime.cpp](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/Basic/ObjCRuntime.cpp),\r\n[CGException.cpp](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CGException.cpp),\r\n[CGObjCGNU.cpp](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CGObjCGNU.cpp),\r\n[CGObjCMac.cpp](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CGObjCMac.cpp),\r\n[CodeGenModule.cpp](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/CodeGen/CodeGenModule.cpp).\r\n\r\nThat's it. Add `-fobjc-runtime=swifter` to the Clang arguments in the Xcode\r\nscheme.\r\nThis should make Cmd-r properly crash in the abort() call in\r\nCGObjCSwifterVirtual::ModuleInitFunction.\r\n\r\nGreat. All the infrastructure is in place now, we 'just' need to generate\r\nthe code :-)\r\n\r\n\r\n#### Step 3: Add a macro for conditional compilation\r\n\r\nSomething easy next. The source should be able to detect whether the Swifter\r\nruntime is in use. Like that:\r\n\r\n    #if __SWIFTER_RUNTIME__\r\n    + (BOOL)isActuallySwift { return YES; }\r\n    #elif __NEXT_RUNTIME__\r\n    + (BOOL)isActuallySwift { return KINDA_REALLY_SWIFT; }\r\n    #endif\r\n\r\nLet's hack this in. Easy enough, this is in\r\nClang Libraries / clangFrontend /\r\n[InitPreprocessor.cpp](https://github.com/AlwaysRightInstitute/clang/blob/r36-swifter/lib/Frontend/InitPreprocessor.cpp). Look for `__NEXT_RUNTIME__`.\r\n\r\nTo try whether it works, add some non-sense like\r\n\r\n    #if __SWIFTER_RUNTIME__\r\n      always right it is\r\n    #endif\r\n\r\nto the ~/hack-a-clang/hello.m and Cmd-r in Xcode. This should now stop the\r\ncompiler due to a syntax error, instead of crashing in our abort().\r\n\r\n\r\n### To be continued ...\r\n\r\nContinue text here ;-)\r\n\r\n\r\n\r\n\r\n### C++\r\n\r\nGiven that you are working on something Objective-C, there is a good chance you\r\nmight miss some C++ basics. And Clang is using pretty much any feature C++\r\nprovides.\r\n\r\n##### private namespaces\r\n\r\nIf you see a namespace declaration w/o a name like this:\r\n\r\n    namespace {\r\n      ...\r\n    }\r\n\r\nit creates a 'private' namespace. Think of it like 'static' in C. The contents\r\nwill only be visible in the current translation unit.\r\n\r\n##### auto\r\n\r\nLet the compiler automatically derive the type, Swift-like. This is\r\ncrap to read as you can't see the type :-) Sample:\r\n\r\n    ExprAST::dump(out << \"var\", ind);\r\n    for (const auto &NamedVar : VarNames) {\r\n      NamedVar.second->dump(indent(out, ind) \r\n        << NamedVar.first << ':', ind + 1);\r\n    }\r\n\r\n##### ampersand reference parameters\r\n\r\nYou'll see a lot of objects being passed around by reference. Like:\r\n\r\n    static uint64_t LookupFieldBitOffset(CodeGen::CodeGenModule &CGM, ...) {\r\n      CGM.doThis()\r\n    }\r\n\r\nInstead of\r\n\r\n    static uint64_t LookupFieldBitOffset(CodeGen::CodeGenModule *CGM, ...) {\r\n      CGM->doThat()\r\n    }\r\n\r\nIt's essentially the same.\r\n\r\n##### const'ness\r\n\r\nThere is a lot of it. You know\r\n\r\n    const char * const ptr;\r\n\r\nDangerous [const_cast](http://en.cppreference.com/w/cpp/language/const_cast)\r\nhack-a-round:\r\n\r\n    void SwifterHackMethodDeclIfNecessary\r\n      (CodeGen::CodeGenModule &cgm, const ObjCMethodDecl *cmethod)\r\n    {\r\n      ObjCMethodDecl *method = const_cast<ObjCMethodDecl *>(cmethod);\r\n    }\r\n\r\n##### std::string\r\n\r\nThis is the C++ string class (actually a template instance of\r\nbasic_string<char>). Clang uses additional string objects, StringRef,\r\nSmallString and Twine.\r\nNote that C strings automatically cast to std::strings etc.\r\nWhen declaring a method argument, use\r\n[StringRef](http://llvm.org/docs/ProgrammersManual.html#the-stringref-class).\r\n\r\nImportant method: stdString.c_str(). Gives you the char* string.\r\n\r\nDifference to NSString? Plenty. Not usually passed as a reference, but as a\r\nvalue object.\r\n\r\n##### std::pair\r\n\r\nJust a pair of two objects. Sample:\r\n\r\n    class VarExprAST : public ExprAST {\r\n      std::vector<std::pair<std::string, ExprAST *> > VarNames;\r\n\r\nThis is an array of string/ptr pairs.\r\n\r\n##### std::vector\r\n\r\nAgain, unlike ObjC, usually allocated as a value object. Sample:\r\n\r\n    std::vector<std::string> titles;\r\n    titles.push_back(\"Hello\");\r\n    titles.push_back(\"World!\");\r\n    for (int i = 0, cnt = titles.size(); i < cnt; i++)\r\n      printf(\"title: %s\\n\", titles[i].c_str());\r\n\r\nYou just have to love C++ ...\r\n\r\n##### RTTI\r\n\r\nIt is worth noting that Clang doesn't use C++ RTTI. Instead it has it's own\r\ndynamic type system. With own 'isa', 'dyn_cast' and 'cast' implementations.\r\n\r\nSample:\r\n\r\n    if (isa<ObjCMethodDecl>)(this))\r\n      return false;\r\n    \r\n    // Swift: if let ai as? AllocationInst { } ...\r\n    if (AllocationInst *ai = dyn_cast<AllocationInst>(val))\r\n      ..\r\n\r\n##### Iterators\r\n\r\nQuite honestly I didn't really get them yet. Must be similar to the Swift\r\nrange stuff I assume :-)\r\n\r\n\r\n### Funny Sidenotes\r\n\r\nCompilation of LLVM and Clang takes a looong time. Working on it feels a lot\r\nlike Unix development in the year 2000. Instead of having instant compiles on\r\nsave, you actually can go and grab a coffee while stuff rebuilds.\r\n\r\n#### Compile Timings\r\n\r\nMachines (all OSX 10.10):\r\n- zAir   (MacBook Air non-PCIe, i7 2GHz, 8GB RAM)\r\n- Zini   (Mac Mini Quad Core i7, 16 GB, Software RAID-0 on OWC SSDs)\r\n- ZPro   (can Mac Pro 4-Core D300 32GB 1TB PCIe)\r\n- ZeePro (can Mac Pro 4-Core D300 16GB 512GB PCIe)\r\n\r\n##### LLVM (w/o embedded clang)\r\n\r\n| Command                  | Machine | Real   | User   | Sys   |\r\n|--------------------------|---------|--------|--------|-------|\r\n| make -j 16               | Zini    | 6m16s  | 40m27s | 3m4s  |\r\n| make -j 16               | ZPro    | 5m8s   | 34m24  | 2m17s |\r\n| make -j  8               | ZPro    | 5m3s   | 31m51s | 2m8s  |\r\n| make -j  8               | zAir    | 11m5s  | 38m2s  | 2m19s |\r\n| make -j  8               | ZeePro  | 4m40s  | 32m3s  | 2m    |\r\n\r\n##### Clang\r\n\r\n| Command                  | Machine | Real   | User   | Sys   |\r\n|--------------------------|---------|--------|--------|-------|\r\n| xcodebuild -target clang | ZPro    | 4m32s  | 25m18s | 1m57s |\r\n| xcodebuild -target clang | zAir    | 9m51s  | 30m7s  | 2m10s |\r\n| make -j 4                | Zini    | 4m52s  | 17m28s | 1m19s |\r\n| xcodebuild -target clang | ZeePro  | 4m26s  | 25m28s | 1m48s |\r\n| make -j 7                | ZeePro  | 4m32s  | 29m49s | 2m34s |\r\n\r\n\r\n###Why?!\r\n\r\nSomeone bothered me to do this, and I was actually interested in how all this\r\nworks. So I gave it a try. I'm not actually using any of this.\r\n\r\n###Contact\r\n\r\n[@helje5](http://twitter.com/helje5) | helge@alwaysrightinstitute.com\r\n\r\n![](http://www.alwaysrightinstitute.com/ARI.png)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}